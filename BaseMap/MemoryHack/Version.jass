/* Provides automatic detection of GameState object, Jass context, Unit
   and Ability object data tables and GameUI object for Mouse functions.
   This code is expected to work on all versions of WC3, even future ones. */

library Version initializer Init requires Memory, optional DummyCaster

globals
    integer GameState
    integer pJassContext
    integer pGameUI
    integer TagTable
    integer StringHandles
    integer array ObjectTables

    integer IsMac = 0
    integer IsLegacy = 0
endglobals

struct HandleTable extends array
    implement MemArray
endstruct

struct GameTypeSupported extends array
    implement MemArray
endstruct

native DebugBreak takes integer i returns nothing

private function GetDummyUnit takes nothing returns unit
    static if LIBRARY_DummyCaster then
        return DUMMY
    else
        return CreateUnit(Player(0), 'uloc', .0, .0, .0)
    endif
endfunction

private struct BC extends array
    static constant boolean hasTrigger = true
    implement Bytecode
endstruct

private function FindDataTable takes integer func, boolean inlined returns integer
    set CustomMem.address = func
    loop
        exitwhen CustomMem[0]/16777216 == 0xFFFFFFE9    //always search after first CALL (E8)
        set CustomMem.address = CustomMem.address + 1
    endloop
    if IsMac == 1 then  //all code in Mac is position-independent, first CALL returns current EIP
        set func = CustomMem.address
        loop
            set CustomMem.address = CustomMem.address + 1
            exitwhen CustomMem[1]/16777216 == 0xFFFFFFE9    //begin searching after 2nd call
        endloop
        loop
            set CustomMem.address = CustomMem.address + 1
            exitwhen CustomMem[2]*256/16777216 == 0xFFFFFF8E and CustomMem[2]/1073741824 == 0xFFFFFFFF  //LEA r32, [r32+offset]
        endloop
        return CustomMem[3] + func + 36
    endif
    if inlined then  //GetUnitData is inlined in 1.27+, windows only.
        loop
            //"CMP r32,-1", followed by JZ SHORT (83F? FF, 74 XX)
            exitwhen CustomMem[2]*16777216 == 0x83000000 and CustomMem[2]/2048 == 0xE9FFF
            set CustomMem.address = CustomMem.address + 1
        endloop
        return CustomMem[1] - 8
    endif
    loop
        set CustomMem.address = CustomMem.address + 1
        exitwhen CustomMem[1]/16777216 == 0xFFFFFFBA     //"MOV ECX, offset" (B9)
    endloop
    return CustomMem[2] + 28
endfunction

private function FindTagTable takes integer func returns integer
    set CustomMem.address = func
    loop
        exitwhen CustomMem[0]/16777216 == 0xFFFFFFE9
        set CustomMem.address = CustomMem.address + 1
    endloop
    set func = CustomMem.address
    //First call in Mac is GetEIP, in Windows it is DecodeTags.
    //To my surprise, DecodeTags is inlined in Mac but not in Windows.
    if IsMac == 1 then
        loop
            set CustomMem.address = CustomMem.address + 1
            exitwhen CustomMem[1]*256/16777216 == 0xFFFFFF8C and CustomMem[1]/1073741824 == 0xFFFFFFFF   //MOV r32, [r32+offset]
        endloop
        return CustomMem[2] + func + 8
    endif
    set CustomMem.address = CustomMem[1] + func + 6  //begin searching at DecodeTags function
    loop
        exitwhen (CustomMem[0]*32/2097152 == 0xFFFFFD8C and (CustomMem[0]+1073741824)/1073741824 == 1) or CustomMem[0]/16777216 == 0xFFFFFFA2  //MOV r32, [address]
        set CustomMem.address = CustomMem.address + 1
    endloop
    return CustomMem[1]
endfunction

private function FindGameUI takes integer func returns integer
    set CustomMem.address = func
    if IsMac == 1 then
        loop
            exitwhen CustomMem[0]/16777216 == 0xFFFFFFE9
            set CustomMem.address = CustomMem.address + 1
        endloop
        set func = CustomMem.address
        loop
            set CustomMem.address = CustomMem.address + 1
            exitwhen CustomMem[1]*256/16777216 == 0xFFFFFF8C and CustomMem[1]/1073741824 == 0xFFFFFFFF  //MOV r32, [r32+offset]
        endloop
        return CustomMem[2] + func + 8
    endif
    loop
        exitwhen CustomMem[0]/65536 == 0xFFFFA365 and CustomMem[1] == 0
        set CustomMem.address = CustomMem.address + 1
    endloop
    if IsLegacy == 1 then
        loop
            set CustomMem.address = CustomMem.address + 1
            exitwhen CustomMem[1]/65536 == 0x3D83   //CMP [address], constant
        endloop
        return CustomMem[2]
    endif
    loop
        set CustomMem.address = CustomMem.address + 1
        exitwhen (CustomMem[1]-0x80000000)/16777216 == 33 or (CustomMem[1]*32/2097152 == 0xFFFFFD8C and (CustomMem[1]+1073741824)/1073741824 == 1)     //MOV r32, [address]
    endloop
    return CustomMem[2]
endfunction

private function Step2 takes integer i returns nothing
    local unit u = GetDummyUnit()
    call UnitAddAbility(u, 'AInv')
    set GameState = i
    set HandleTable.address = Memory[Memory[GameState/4+7]/4+103] - 0xBFFFFC
    set GameTypeSupported.address = Memory[GameState/4+12]+48
    set i = HandleTable[GetHandleId(u)*3]/4     //ConvertHandle(u)
    set CustomMem.address = Memory[Memory[i]/4+88+IsMac]-3
    loop
        exitwhen (CustomMem[0]-0x80000000)/33554432 == 52  //matches both CALL (0xE8) and JMP (0xE9)
        set CustomMem.address = CustomMem.address + 1
    endloop
    set ObjectTables[0] = FindDataTable(CustomMem[1] + CustomMem.address + 5, (IsLegacy == 0))/4    //GetUnitData is inlined on 1.27+, windows only.
    set CustomMem.address = Memory[Memory[Memory[i+126]/4]/4+16+IsMac]-3
    loop
        exitwhen CustomMem[0]/16777216 == 0xFFFFFFE9    //Skip first CALL
        set CustomMem.address = CustomMem.address + 1
    endloop
    loop
        set CustomMem.address = CustomMem.address + 1
        exitwhen CustomMem[1]/16777216 == 0xFFFFFFE9    //2nd CALL is GetAbilityData
    endloop
    set ObjectTables[1] = FindDataTable(CustomMem[2] + CustomMem.address + 9, false)/4  //GetAbilityData is never inlined
    set TagTable = FindTagTable(Memory[Memory[HandleTable[GetHandleId(Condition(function GetDummyUnit))*3]/4]/4+30+IsMac])/4
    set CustomMem.address = Memory[Memory[i]/4+101+IsMac]
    if IsMac == 1 then  //First call in Mac is GetEIP, so skip it
        loop
            exitwhen CustomMem[0]/16777216 == 0xFFFFFFE9  
            set CustomMem.address = CustomMem.address + 1
        endloop
    endif
    loop
        set CustomMem.address = CustomMem.address + 1
        exitwhen CustomMem[1]/16777216 == 0xFFFFFFE9    //2nd CALL is GetAbilityData
    endloop
    set pGameUI = FindGameUI(CustomMem[2] + CustomMem.address + 9)/4
    static if LIBRARY_Mouse then
        set MouseEnv.address = Memory[Memory[pGameUI]/4 + 239]+784
    endif
    static if not LIBRARY_DummyCaster then
        call RemoveUnit(u)
    endif
    set u = null
endfunction

private function Step1 takes integer p, integer i returns nothing
    set i = i/4
    loop
        exitwhen Memory[i] == BC.address and Memory[i+3] == 300000
        set i = i+1
    endloop
    set pJassContext = Memory[i-1]
    if Memory[pJassContext/4+17] == 300000 then
        set IsMac = 1
    else
        loop
            set i = i-1
            set pJassContext = Memory[i]
            exitwhen ModuloInteger(pJassContext*65536/65536, 0x28B0) == 0x88 and pJassContext>65536 and Memory[pJassContext/4+17] == 300000
        endloop
    endif
    set StringHandles = Memory[pJassContext/4+2589]/4+2
    if p != GetPlayers() then
        set BC(33).value = 623    //SetPlayers
        return
    endif
    set IsLegacy = 1
    if IsMac == 1 then
        set BC(28).value = 0x13000000
        set BC(33).value = 631    //SetStartLocPrio
        return
    endif
    set BC[33] = 642        //SetGamePlacement
    call GetGamePlacement()
    return
endfunction

private function DebugBreak_Id takes nothing returns nothing
    call DebugBreak(0)
endfunction

//# +nosemanticerror
private function InitBytecode takes nothing returns nothing
    set BC[0] = 0x15000000
    set BC[1] = 652         //GetPlayers
    set BC[2] = 0x13000000
    set BC[4] = 0x15000000
    set BC[5] = 623         //SetPlayers
    set BC[6] = 0x17000000
    set BC[8] = 0x13000000
    set BC[10] = 0x15000000
    set BC[11] = 595        //R2I
    set BC[12] = 0x13000000
    set BC[14] = 0x13000000
    set BC[16] = 0x15000000
    set BC[17] = Memory[C2I(function DebugBreak_Id)/4+5]
    set BC[18] = 0x17000000
    set BC[20] = 0x13000000
    set BC[22] = 0x15000000
    set BC[23] = 595        //R2I
    set BC[24] = 0x13000000
    set BC[26] = 0x16000000
    set BC[27] = Memory[C2I(function Step1)/4-1]
    set BC[30] = 0x13000000
    set BC[32] = 0x15000000
    set BC[34] = 0x0D010000
    set BC[36] = 0x17000000
    set BC[38] = 0x13000000
    set BC[40] = 0x15000000
    set BC[41] = 595        //R2I
    set BC[42] = 0x21010100
    set BC[44] = 0x17010000
    set BC[46] = 0x13010000
    set BC[48] = 0x0D010000
    set BC[50] = 0x15000000
    set BC[51] = 595        //R2I
    set BC[52] = 0x20000100
    set BC[54] = 0x13000000
    set BC[56] = 0x16000000
    set BC[57] = Memory[C2I(function Step2)/4-1]
    set BC[58] = 0x27000000
endfunction

private function Init takes nothing returns nothing
    call InitBytecode()
    call TriggerRegisterGameEvent(BC.trigger, EVENT_GAME_LOADED)
    call TriggerEvaluate(BC.trigger)
endfunction

endlibrary